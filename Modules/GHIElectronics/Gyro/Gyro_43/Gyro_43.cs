using System;
using Microsoft.SPOT;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.SocketInterfaces;

namespace Gadgeteer.Modules.GHIElectronics
{
    /// <summary>
    /// A Gyro module for Microsoft .NET Gadgeteer, based on the InvenSense ITG-3200 module
    /// </summary>
    public class Gyro : GTM.Module
    {

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public Gyro(int socketNumber)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);

            offsets = new CalibrationOffsets(0, 0, 0);

            // Init I2C
            i2c = GTI.I2CBusFactory.Create(socket, 0x68, 100, this);
            SetFullScaleRange();

            continuousTimer = new Gadgeteer.Timer(new TimeSpan(0, 0, 0, 0, 100));
            continuousTimer.Tick += new Timer.TickEventHandler(continuousTimer_Tick);

            // This creates an GTI.InterruptInput interface. The interrupt can be configured to announce when new data is ready.
            // Currently, this functionality is unused.
            //  this.interruptInput = GTI.InterruptInputFactory.Create(socket, GT.Socket.Pin.Three, GTI.GlitchFilterMode.Off, GTI.ResistorMode.PullDown, GTI.InterruptMode.RisingEdge, this);
            this.interruptInput = GTI.InterruptInputFactory.Create(socket, GT.Socket.Pin.Three, GTI.GlitchFilterMode.Off, GTI.ResistorMode.Disabled, GTI.InterruptMode.RisingEdge, this);
            this.interruptInput.Interrupt += interruptInput_Interrupt;
        }

        GTI.I2CBus i2c;
        private GTI.InterruptInput interruptInput;

        private GT.Timer continuousTimer;
        private bool continuousMeasurement = false;

        // Read/Write buffers
        private byte[] readBuffer8 = new byte[1];
        private byte[] writeBuffer8 = new byte[1];
        private byte[] writeBuffer16 = new byte[2];
        private byte[] readBuffer64 = new byte[8];

        // Used to store calibration settings in non-volatile memory
        private static ExtendedWeakReference calibrationEWR = null;

        [Serializable]
        private class CalibrationOffsets
        {
            public double X = 0;
            public double Y = 0;
            public double Z = 0;

            public CalibrationOffsets(double x, double y, double z)
            {
                X = x;
                Y = y;
                Z = z;
            }
        }

        private CalibrationOffsets offsets;

        /// <summary>
        /// A set of sensor measurements.
        /// </summary>
        public class SensorData
        {
            /// <summary>
            /// Angular rate around the X axis (roll), in degree per second.
            /// </summary>
            public double X { get; private set; }
            /// <summary>
            /// Angular rate around the Y axis (pitch), in degree per second.
            /// </summary>
            public double Y { get; private set; }
            /// <summary>
            /// Angular rate around the Z axis (yaww), in degree per second.
            /// </summary>
            public double Z { get; private set; }
            /// <summary>
            /// Temperature, in degree celsius.
            /// </summary>
            public double Temperature { get; private set; }

            /// <summary>
            /// A set of sensor measurements.
            /// </summary>
            /// <param name="x">Angular rate around the X axis (roll), in degree per second.</param>
            /// <param name="y">Angular rate around the Y axis (pitch), in degree per second.</param>
            /// <param name="z">Angular rate around the Z axis (yaww), in degree per second.</param>
            /// <param name="temperature">Temperature, in degree celsius.</param>
            public SensorData(double x, double y, double z, double temperature)
            {
                this.X = x;
                this.Y = y;
                this.Z = z;
                this.Temperature = temperature;
            }

            /// <summary>
            /// Provides a string representation of the <see cref="SensorData"/> instance.
            /// </summary>
            /// <returns>A string describing the values contained in the object.</returns>
            public override string ToString()
            {
                return "X: " + X.ToString("f2") + " Y: " + Y.ToString("f2") + " Z: " + Z.ToString("f2") + " Temperature: " + Temperature.ToString("f2");
            }
        }
        /// <summary>
        /// Available low pass filter bandwidth settings.
        /// </summary>
        public enum Bandwidth
        {
            _256Hz = 0,
            _188Hz = 1,
            _98Hz = 2,
            _42Hz = 3,
            _20Hz = 4,
            _10Hz = 5,
            _5Hz = 6
        }

        /// <summary>
        /// Gets or sets the low pass filter configuration. Note that setting the low pass filter to 256Hz results in a maximum internal sample rate
        /// of 8kHz. Any other setting results in a maximum sample rate of 1kHz. The sample rate can be further divided by using the SampleRateDivider
        /// property.
        /// </summary>
        public Bandwidth LowPassFilter
        {
            get
            {
                byte b = ReadByte(Register.DLPF_FS);
                return (Bandwidth)(b & 0x7); // Read bits 0-2
            }
            set
            {
                // Bits 0-2 in the DPLF_FS register set the low pass filter. Allways set bits 3 and 4 (see SetFullScaleRange).
                Write(Register.DLPF_FS, (byte)(((byte)value) | 0x18));
            }
        }

        /// <summary>
        /// Sets the internal sample rate divider. The gyro outputs are sampled internally at either 8kHz (if the LowPassFilter is set to 256Hz) or 1kHz for any other LowPassFilter settings. This settin can be used to further divide the sample rate. Valid values are between 0 and 255.
        /// </summary>
        public byte SampleRateDivider
        {
            get
            {
                return ReadByte(Register.SMPLRT_DIV);
            }
            set
            {
                Write(Register.SMPLRT_DIV, value);
            }
        }

        /// <summary>
        /// Gets or sets the interval at which continuous measurements are taken.
        /// </summary>
        /// <remarks>
        /// The default value for this property is 100 milliseconds.
        /// </remarks>
        public TimeSpan ContinuousMeasurementInterval
        {
            get
            {
                return continuousTimer.Interval;
            }
            set
            {
                continuousTimer.Stop();
                continuousTimer.Interval = value;
                if (continuousMeasurement) continuousTimer.Start();
            }
        }

        private void SetFullScaleRange()
        {
            // Range should always be set to 0x03 (full range) for correct operation. Power-on default for FS_SEL (bits 3 and 4 in PLPF_FS register) is 0x00.
            byte b = ReadByte(Register.DLPF_FS);
            Write(Register.DLPF_FS, (byte)(b | 0x18));
        }

        private void EnableInterruptOnDataReady()
        {
            // Logic level = active high
            // Drive type = push-pull
            // Latch mode = latch until interrupt is cleared
            // Enable interrupt when data is available.
            Write(Register.INT_CFG, 0x21);

            // Read the status register in order to clear the interrupt latch
            ReadByte(Register.INT_STATUS);
        }

        private void DisableInterruptOnDataReady()
        {
            // Logic level = active high
            // Drive type = push-pull
            // Latch mode = latch until interrupt is cleared
            // Disable interrupt when data is available.
            Write(Register.INT_CFG, 0x20);
        }



        private enum Register : byte
        {
            // From PS-ITG-3200-00-01.4.pdf Datasheet, pg. 22.              
            //                          R/W    Bit 7    Bit 6    Bit 5    Bit 4    Bit 3    Bit 2    Bit 1    Bit 0   
            // ------------------------------------------------------------------------------------------------------
            WHO_AM_I = 0x00,        //  R/W    
            SMPLRT_DIV = 0x15,      //  R/W 
            DLPF_FS = 0x16,         //  R/W
            INT_CFG = 0x17,         //  R/W    ACTL    OPEN     LATCH_  INT_ANYRD_   -      ITG_RDY    -      RAW_
            //                          INT_EN  2CLEAR              _EN               RDY_EN
            INT_STATUS = 0x1A,     //  R
            TEMP_OUT_H = 0x1B,     //  R
            TEMP_OUT_L = 0x1C,     //  R
            GYRO_OUT_XOUT_H = 0x1D, //  R
            GYRO_OUT_XOUT_L = 0x1E, //  R
            GYRO_OUT_YOUT_H = 0x1F, //  R
            GYRO_OUT_YOUT_L = 0x20, //  R
            GYRO_OUT_ZOUT_H = 0x21, //  R
            GYRO_OUT_ZOUT_L = 0x22, //  R
            PWR_MGM = 0x3E      //  R/W
        }



        private byte ReadByte(Register register)
        {
            writeBuffer8[0] = (byte)register;
            i2c.WriteRead(writeBuffer8, readBuffer8);
            return readBuffer8[0];
        }

        private void Read(Register register, byte[] readBuffer)
        {
            writeBuffer8[0] = (byte)register;
            i2c.WriteRead(writeBuffer8, readBuffer);
        }

        private void Write(Register register, byte value)
        {
            writeBuffer16[0] = (byte)register;
            writeBuffer16[1] = (byte)value;
            i2c.Write(writeBuffer16);
        }

        /// <summary>
        /// Requests a single reading from the <see cref="Gyro"/> and raises the <see cref="MeasurementComplete"/> event when complete.
        /// </summary>
        public void RequestMeasurement()
        {
            int rawX, rawY, rawZ, rawT;

            // Read all the output registers at once.
            Read(Register.TEMP_OUT_H, readBuffer64);
            rawT = (readBuffer64[0] << 8) | readBuffer64[1];
            rawX = (readBuffer64[2] << 8) | readBuffer64[3];
            rawY = (readBuffer64[4] << 8) | readBuffer64[5];
            rawZ = (readBuffer64[6] << 8) | readBuffer64[7];

            // Decode 2's complement encoding
            rawT = (((rawT >> 15) == 1) ? -32767 : 0) + (rawT & 0x7FFF);
            rawX = (((rawX >> 15) == 1) ? -32767 : 0) + (rawX & 0x7FFF);
            rawY = (((rawY >> 15) == 1) ? -32767 : 0) + (rawY & 0x7FFF);
            rawZ = (((rawZ >> 15) == 1) ? -32767 : 0) + (rawZ & 0x7FFF);

            // Gyro sensitivity = 14.375 LSB per degree/sec
            double x = ((double)rawX / 14.375) + offsets.X;
            double y = ((double)rawY / 14.375) + offsets.Y;
            double z = ((double)rawZ / 14.375) + offsets.Z;

            // Convert temperature to degrees celsius
            // Temperature offset of 35 degrees celsius, 230 LSB per degree celsius
            double t = (((double)rawT + 13200) / 280.0) + 35;

            SensorData sensorData = new SensorData(x, y, z, t);
            OnMeasurementCompleteEvent(this, sensorData);
        }

        /// <summary>
        /// Calibrates the gyro values. Ensure that the sensor is not moving when calling this method.
        /// </summary>
        public void Calibrate()
        {
            int rawX, rawY, rawZ, rawT;

            // Read all the output registers at once.
            Read(Register.TEMP_OUT_H, readBuffer64);
            rawT = (readBuffer64[0] << 8) | readBuffer64[1];
            rawX = (readBuffer64[2] << 8) | readBuffer64[3];
            rawY = (readBuffer64[4] << 8) | readBuffer64[5];
            rawZ = (readBuffer64[6] << 8) | readBuffer64[7];

            // Decode 2's complement encoding
            rawT = (((rawT >> 15) == 1) ? -32767 : 0) + (rawT & 0x7FFF);
            rawX = (((rawX >> 15) == 1) ? -32767 : 0) + (rawX & 0x7FFF);
            rawY = (((rawY >> 15) == 1) ? -32767 : 0) + (rawY & 0x7FFF);
            rawZ = (((rawZ >> 15) == 1) ? -32767 : 0) + (rawZ & 0x7FFF);

            // Gyro sensitivity = 14.375 LSB per degree/sec
            double x = ((double)rawX / 14.375);
            double y = ((double)rawY / 14.375);
            double z = ((double)rawZ / 14.375);

            offsets.X = -x;
            offsets.Y = -y;
            offsets.Z = -z;
        }

        /// <summary>
        /// Saves the calibration values to non-volatile memory.
        /// </summary>
        public void SaveCalibration()
        {
            if (calibrationEWR == null)
            {
                calibrationEWR = ExtendedWeakReference.RecoverOrCreate(typeof(CalibrationOffsets), 0, ExtendedWeakReference.c_SurviveBoot | ExtendedWeakReference.c_SurvivePowerdown);
                calibrationEWR.Priority = (int)ExtendedWeakReference.PriorityLevel.NiceToHave;
            }

            calibrationEWR.Target = offsets;
        }

        /// <summary>
        /// Loads previously saved calibration settings.
        /// </summary>
        /// <returns>True if previously saved settinsg were found. False otherwise.</returns>
        public bool LoadCalibration()
        {
            if (calibrationEWR == null)
            {
                calibrationEWR = ExtendedWeakReference.RecoverOrCreate(typeof(CalibrationOffsets), 0, ExtendedWeakReference.c_SurviveBoot | ExtendedWeakReference.c_SurvivePowerdown);
                calibrationEWR.Priority = (int)ExtendedWeakReference.PriorityLevel.NiceToHave;
            }

            CalibrationOffsets savedOffsets = (CalibrationOffsets)calibrationEWR.Target;

            if (savedOffsets != null)
            {
                offsets = savedOffsets;
                return true;
            }
            else
            {
                offsets = new CalibrationOffsets(0, 0, 0);
            }

            return false;
        }

        /// <summary>
        /// Starts continuous measurements.
        /// </summary>
        /// <remarks>
        /// When this method is called, the <see cref="Gyro"/> begins taking continuous measurements.
        /// At each <see cref="ContinuousMeasurementInterval"/>, it calls the <see cref="RequestMeasurement"/> method,
        /// which raises the <see cref="MeasurementComplete"/> event.
        /// </remarks>
        public void StartContinuousMeasurements()
        {
            continuousMeasurement = true;
            continuousTimer.Start();
        }

        /// <summary>
        /// Stops continuous measurements.
        /// </summary>
        public void StopContinuousMeasurements()
        {
            continuousMeasurement = false;
            continuousTimer.Stop();
        }

        void continuousTimer_Tick(Timer timer)
        {
            if (!continuousMeasurement)
            {
                timer.Stop();
                return;
            }
            RequestMeasurement();
        }

        private void interruptInput_Interrupt(GTI.InterruptInput sender, bool value)
        {
            // Read the status register in order to clear the interrupt latch
            ReadByte(Register.INT_STATUS);
            //Raise the MeasurementReady event.
            OnDataReady(this);
        }

        /// <summary>
        /// Represents the delegate used for the <see cref="MeasurementComplete"/> event.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="sensorData">The <see cref="SensorData"/> object that contains the results of the reading.</param>
        public delegate void MeasurementCompleteEventHandler(Gyro sender, SensorData sensorData);

        /// <summary>
        /// Event raised when a measurement reading is completed.
        /// </summary>
        public event MeasurementCompleteEventHandler MeasurementComplete;

        private MeasurementCompleteEventHandler _OnMeasurementComplete;

        /// <summary>
        /// Raises the <see cref="MeasurementComplete"/> event.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="sensorData">The <see cref="SensorData"/> object that contains the results of the measurement.</param>
        protected virtual void OnMeasurementCompleteEvent(Gyro sender, SensorData sensorData)
        {
            if (_OnMeasurementComplete == null) _OnMeasurementComplete = new MeasurementCompleteEventHandler(OnMeasurementCompleteEvent);
            if (Program.CheckAndInvoke(MeasurementComplete, _OnMeasurementComplete, sender, sensorData))
            {
                MeasurementComplete(sender, sensorData);
            }
        }

        /// <summary>
        /// Represents the delegate that is used to handle the <see cref="DataReady"/> event
        /// </summary>
        /// <param name="sender">The <see cref="Gyro"/> object that raised the event.</param>
        public delegate void DataReadyHandler(Gyro sender);

        private event DataReadyHandler _OnDataAvailable;
        private int eventHandlers = 0;

        /// <summary>
        /// Triggered when a new measurement is ready to be read. To read the new data, call the <see cref="RequestMeasurement"/> method, and handle the <see cref="MeasurementComplete"/> event. Alternatively, you can use the <see cref="StartContinuousMeasurements"/> method to 
        /// sample data at the interval specified by the <see cref="ContinuousMeasurementInterval"/> property, although this might result in duplicate data being read or data being missed, depending on the sample rate.
        /// </summary>
        public event DataReadyHandler DataReady
        {
            add
            {
                // Enable the interrupt input the first time an event handler is registered.
                if (eventHandlers == 0)
                {
                    EnableInterruptOnDataReady();
                }

                eventHandlers++;
                _OnDataAvailable += value;
            }
            remove
            {
                eventHandlers--;
                if (eventHandlers == 0)
                {
                    // If no event handlers are registered, disable interrupt on data ready.
                    DisableInterruptOnDataReady();
                }
                _OnDataAvailable -= value;
            }
        }

        private DataReadyHandler onDataReady;

        /// <summary>
        /// Raises the <see cref="DataReady"/> event.
        /// </summary>
        /// <param name="sender"></param>
        protected virtual void OnDataReady(Gyro sender)
        {
            if (this.onDataReady == null)
            {
                this.onDataReady = new DataReadyHandler(this.OnDataReady);
            }

            if (Program.CheckAndInvoke(_OnDataAvailable, this.onDataReady, sender))
            {
                this._OnDataAvailable(sender);
            }
        }

    }
}
