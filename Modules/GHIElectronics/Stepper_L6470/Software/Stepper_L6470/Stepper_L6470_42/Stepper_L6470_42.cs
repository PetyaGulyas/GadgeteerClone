using System;
using Microsoft.SPOT;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;

using System.Threading;

namespace Gadgeteer.Modules.GHIElectronics
{
    // -- CHANGE FOR MICRO FRAMEWORK 4.2 --
    // If you want to use Serial, SPI, or DaisyLink (which includes GTI.SoftwareI2C), you must do a few more steps
    // since these have been moved to separate assemblies for NETMF 4.2 (to reduce the minimum memory footprint of Gadgeteer)
    // 1) add a reference to the assembly (named Gadgeteer.[interfacename])
    // 2) in GadgeteerHardware.xml, uncomment the lines under <Assemblies> so that end user apps using this module also add a reference.

    /// <summary>
    /// A Stepper_L6470 module for Microsoft .NET Gadgeteer
    /// </summary>
    public class Stepper_L6470 : GTM.Module
    {
        private GT.Interfaces.SPI.Configuration spiConfig;
        private GT.Interfaces.SPI spi;

        private GT.Interfaces.DigitalInput busyPin;
        private GT.Interfaces.DigitalOutput resetPin;
        public GT.Interfaces.DigitalOutput stepClock;

        private RegsStruct regsStruct;

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public Stepper_L6470(int socketNumber)
        {
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);

            socket.EnsureTypeIsSupported('S', this);

            // Initialize SPI
            spiConfig = new GTI.SPI.Configuration(false, 1000, 1000, true, true, 5000);
            spi = new GTI.SPI(socket, spiConfig, GTI.SPI.Sharing.Shared, socket, Socket.Pin.Six, this);

            // Initialize pins
            busyPin = new GTI.DigitalInput(socket, Socket.Pin.Three, GTI.GlitchFilterMode.Off, GTI.ResistorMode.PullUp, this);
            resetPin = new GTI.DigitalOutput(socket, Socket.Pin.Four, true, this);
            stepClock = new GTI.DigitalOutput(socket, Socket.Pin.Five, false, this);

            // Initialize chip registers
            InitializeChip();

            Reset();
        }

        private void InitializeChip()
        {
            regsStruct = new RegsStruct();
            Regs_Struct_Reset(regsStruct);

            /* Acceleration rate settings to 466 steps/s2, range 14.55 to 59590 steps/s2 */
            regsStruct.ACC = AccDec_Steps_to_Par(466);
            /* Deceleration rate settings to 466 steps/s2, range 14.55 to 59590 steps/s2 */
            regsStruct.DEC = AccDec_Steps_to_Par(466);
            /* Maximum speed settings to 488 steps/s, range 15.25 to 15610 steps/s */
            regsStruct.MAX_SPEED = MaxSpd_Steps_to_Par(488);
            /* Minimum speed settings to 0 steps/s, range 0 to 976.3 steps/s */
            regsStruct.MIN_SPEED = MinSpd_Steps_to_Par(0);
            /* Full step speed settings 252 steps/s, range 7.63 to 15625 steps/s */
            regsStruct.FS_SPD = FSSpd_Steps_to_Par(252);
            /* Hold duty cycle (torque) settings to 10%, range 0 to 99.6% */
            regsStruct.KVAL_HOLD = Kval_Perc_to_Par(10);
            /* Run duty cycle (torque) settings to 10%, range 0 to 99.6% */
            regsStruct.KVAL_RUN = Kval_Perc_to_Par(10);
            /* Acceleration duty cycle (torque) settings to 10%, range 0 to 99.6% */
            regsStruct.KVAL_ACC = Kval_Perc_to_Par(10);
            /* Deceleration duty cycle (torque) settings to 10%, range 0 to 99.6% */
            regsStruct.KVAL_DEC = Kval_Perc_to_Par(10);
            /* Intersect speed settings for BEMF compensation to 200 steps/s, range 0 to 3906 steps/s */
            regsStruct.INT_SPD = IntSpd_Steps_to_Par(200);
            /* BEMF start slope settings for BEMF compensation to 0.038% step/s, range 0 to 0.4% s/step */
            regsStruct.ST_SLP = BEMF_Slope_Perc_to_Par((float)0.038);
            /* BEMF final acc slope settings for BEMF compensation to 0.063% step/s, range 0 to 0.4% s/step */
            regsStruct.FN_SLP_ACC = BEMF_Slope_Perc_to_Par((float)0.063);
            /* BEMF final dec slope settings for BEMF compensation to 0.063% step/s, range 0 to 0.4% s/step */
            regsStruct.FN_SLP_DEC = BEMF_Slope_Perc_to_Par((float)0.063);
            /* Thermal compensation param settings to 1, range 1 to 1.46875 */
            regsStruct.K_THERM = KTherm_to_Par(1);
            /* Overcurrent threshold settings to 1500mA */
            regsStruct.OCD_TH = (byte)Overcurrent_Detection_Threshold.OCD_TH_1500mA;
            /* Stall threshold settings to 1000mA, range 31.25 to 4000mA */
            regsStruct.STALL_TH = StallTh_to_Par(1000);
            /* Step mode settings to 128 microsteps */
            regsStruct.STEP_MODE = (byte)Step_Select.STEP_SEL_1_128;
            /* Alarm settings - all alarms enabled */
            regsStruct.ALARM_EN = (byte)Alarm_Enable.ALARM_EN_OVERCURRENT | (byte)Alarm_Enable.ALARM_EN_THERMAL_SHUTDOWN
                | (byte)Alarm_Enable.ALARM_EN_THERMAL_WARNING | (byte)Alarm_Enable.ALARM_EN_UNDER_VOLTAGE | (byte)Alarm_Enable.ALARM_EN_STALL_DET_A
                | (byte)Alarm_Enable.ALARM_EN_STALL_DET_B | (byte)Alarm_Enable.ALARM_EN_SW_TURN_ON | (byte)Alarm_Enable.ALARM_EN_WRONG_NPERF_CMD;
            /* Internal oscillator, 2MHz OSCOUT clock, supply voltage compensation disabled, *
             * overcurrent shutdown enabled, slew-rate = 290 V/us, PWM frequency = 15.6kHz   */
            regsStruct.CONFIG = (ushort)CONFIG_OSC_MGMT.CONFIG_INT_16MHZ_OSCOUT_2MHZ | (ushort)CONFIG_SW_MODE_TypeDef.CONFIG_SW_HARD_STOP
                | (ushort)CONFIG_EN_VSCOMP.CONFIG_VS_COMP_DISABLE | (ushort)CONFIG_OC_SD.CONFIG_OC_SD_ENABLE | (ushort)CONFIG_POW_SR.CONFIG_SR_290V_us
                | (ushort)CONFIG_F_PWM_INT.CONFIG_PWM_DIV_2 | (ushort)CONFIG_F_PWM_DEC.CONFIG_PWM_MUL_1;

            /* Program all dSPIN registers */
            SetRegisters(regsStruct);
        }

        /// <summary>
        /// Resets the module
        /// </summary>
        public void Reset()
        {
            resetPin.Write(false);
            Thread.Sleep(500);
            resetPin.Write(true);
            Thread.Sleep(1000);
        }

        private byte WriteByte(byte data)
        {
            byte[] send = new byte[] { data };
            byte[] receive = new byte[1];

            // LOOK HERE IF PROBLEMS
            //spi.WriteRead(send, 0, 1, receive, 0, 1, 0);
            spi.WriteRead(send, receive);

            return receive[0];
        }

        /// <summary>
        /// Send NOP operation code to the module
        /// </summary>
        public void NOP()
        {
            WriteByte((byte)Commands.NOP);
        }

        /// <summary>
        /// Sets a parameter to the passed in value
        /// </summary>
        /// <param name="param">Parameter to set</param>
        /// <param name="value">Value to set</param>
        public void SetParam(Registers param, uint value)
        {
            WriteByte((byte)(((byte)(Commands.SET_PARAM) | (byte)(param))));
            switch (param)
            {
                case Registers.ABS_POS:
                case Registers.MARK:
                case Registers.SPEED:
                    /* Send parameter - byte 2 to dSPIN */
                    WriteByte((byte)(value >> 16));
                    WriteByte((byte)(value >> 8));
                    WriteByte((byte)(value));
                    break;
                case Registers.ACC:
                case Registers.DEC:
                case Registers.MAX_SPEED:
                case Registers.MIN_SPEED:
                case Registers.FS_SPD:
                case Registers.INT_SPD:
                case Registers.CONFIG:
                case Registers.STATUS:
                    /* Send parameter - byte 1 to dSPIN */
                    WriteByte((byte)(value >> 8));
                    WriteByte((byte)(value));
                    break;
                default:
                    /* Send parameter - byte 0 to dSPIN */
                    WriteByte((byte)(value));
                    break;
            }
        }

        /// <summary>
        /// Get a value for a given parameter
        /// </summary>
        /// <param name="param">Parameter to retrieve</param>
        /// <returns></returns>
        public uint GetParam(Registers param)
        {
            uint temp = 0;
            uint rx = 0;

            /* Send GetParam operation code to dSPIN */
            temp = WriteByte((byte)((byte)Commands.GET_PARAM | (byte)param));
            /* MSB which should be 0 */
            temp = temp << 24;
            rx |= temp;
            switch (param)
            {
                case Registers.ABS_POS:
                case Registers.MARK:
                case Registers.SPEED:
                    temp = WriteByte((byte)(0x00));
                    temp = temp << 16;
                    rx |= temp;
                    temp = WriteByte((byte)(0x00));
                    temp = temp << 8;
                    rx |= temp;
                    temp = WriteByte((byte)(0x00));
                    rx |= temp;
                    break;
                case Registers.ACC:
                case Registers.DEC:
                case Registers.MAX_SPEED:
                case Registers.MIN_SPEED:
                case Registers.FS_SPD:
                case Registers.INT_SPD:
                case Registers.CONFIG:
                case Registers.STATUS:
                    temp = WriteByte((byte)(0x00));
                    temp = temp << 8;
                    rx |= temp;
                    temp = WriteByte((byte)(0x00));
                    rx |= temp;
                    break;
                default:
                    temp = WriteByte((byte)(0x00));
                    rx |= temp;
                    break;
            }
            return rx;
        }

        /// <summary>
        /// Runs the motor
        /// </summary>
        /// <param name="direction">Direction of the motor</param>
        /// <param name="speed">Speed of the motor</param>
        public void Run(Direction direction, uint speed)
        {
            /* Send RUN operation code to dSPIN */
            WriteByte((byte)((byte)(Commands.RUN) | (byte)(direction)));
            /* Send speed - byte 2 data dSPIN */
            WriteByte((byte)(speed >> 16));
            /* Send speed - byte 1 data dSPIN */
            WriteByte((byte)(speed >> 8));
            /* Send speed - byte 0 data dSPIN */
            WriteByte((byte)(speed));
        }

        /// <summary>
        /// Steps the motor while the stepClock pin is high
        /// </summary>
        /// <param name="direction">Direction of the motor</param>
        public void StepClock(Direction direction)
        {
            /* Send StepClock operation code to dSPIN */
            WriteByte((byte)((byte)(Commands.STEP_CLOCK) | (byte)(direction)));
        }

        /// <summary>
        /// Moves the motor in the passed in direction for the passed in steps
        /// </summary>
        /// <param name="direction">Direction to move the motor</param>
        /// <param name="n_step">Number of steps to move</param>
        public void Move(Direction direction, uint n_step)
        {
            /* Send Move operation code to dSPIN */
            WriteByte((byte)((byte)Commands.MOVE | (byte)direction));
            /* Send n_step - byte 2 data dSPIN */
            WriteByte((byte)(n_step >> 16));
            /* Send n_step - byte 1 data dSPIN */
            WriteByte((byte)(n_step >> 8));
            /* Send n_step - byte 0 data dSPIN */
            WriteByte((byte)(n_step));
        }

        /// <summary>
        /// Sets the motor to a specific position
        /// </summary>
        /// <param name="abs_pos">Absolute position to move to</param>
        public void GoToPosition(uint abs_pos)
        {
            /* Send GoTo operation code to dSPIN */
            WriteByte((byte)Commands.GO_TO);
            /* Send absolute position parameter - byte 2 data to dSPIN */
            WriteByte((byte)(abs_pos >> 16));
            /* Send absolute position parameter - byte 1 data to dSPIN */
            WriteByte((byte)(abs_pos >> 8));
            /* Send absolute position parameter - byte 0 data to dSPIN */
            WriteByte((byte)(abs_pos));
        }

        /// <summary>
        /// Moves to a specific position, going in the passed in direction
        /// </summary>
        /// <param name="direction">Direction to move</param>
        /// <param name="abs_pos">Absolute position to move to</param>
        public void GoToDirection(Direction direction, uint abs_pos)
        {
            /* Send GoTo_DIR operation code to dSPIN */
            WriteByte((byte)((byte)Commands.GO_TO_DIR | (byte)direction));
            /* Send absolute position parameter - byte 2 data to dSPIN */
            WriteByte((byte)(abs_pos >> 16));
            /* Send absolute position parameter - byte 1 data to dSPIN */
            WriteByte((byte)(abs_pos >> 8));
            /* Send absolute position parameter - byte 0 data to dSPIN */
            WriteByte((byte)(abs_pos));
        }

        /// <summary>
        /// Moves the motor until a specific action happens
        /// </summary>
        /// <param name="action">Action to stop on</param>
        /// <param name="direction">Direction to move</param>
        /// <param name="speed">Speed to move in</param>
        public void GoUntil(Action action, Direction direction, uint speed)
        {
            /* Send GoUntil operation code to dSPIN */
            WriteByte((byte)((byte)Commands.GO_UNTIL | (byte)action | (byte)direction));
            /* Send speed parameter - byte 2 data to dSPIN */
            WriteByte((byte)(speed >> 16));
            /* Send speed parameter - byte 1 data to dSPIN */
            WriteByte((byte)(speed >> 8));
            /* Send speed parameter - byte 0 data to dSPIN */
            WriteByte((byte)(speed));
        }

        /// <summary>
        /// TODO
        /// </summary>
        /// <param name="action"></param>
        /// <param name="direction"></param>
        public void ReleaseSW(Action action, Direction direction)
        {
            /* Send ReleaseSW operation code to dSPIN */
            WriteByte((byte)((byte)Commands.RELEASE_SW | (byte)action | (byte)direction));
        }

        /// <summary>
        /// Moves the motor to the home position
        /// </summary>
        public void GoHome()
        {
            /* Send GoHome operation code to dSPIN */
            WriteByte((byte)Commands.GO_HOME);
        }

        /// <summary>
        /// Goes the motor to the mark position
        /// </summary>
        public void GoMark()
        {
            /* Send GoMark operation code to dSPIN */
            WriteByte((byte)Commands.GO_MARK);
        }

        /// <summary>
        /// Resets the motor to the position
        /// </summary>
        public void ResetPos()
        {
            /* Send ResetPos operation code to dSPIN */
            WriteByte((byte)Commands.RESET_POS);
        }

        /// <summary>
        /// Resets the device
        /// </summary>
        public void ResetDevice()
        {
            /* Send ResetDevice operation code to dSPIN */
            WriteByte((byte)Commands.RESET_DEVICE);
        }

        /// <summary>
        /// Soft stop operation
        /// </summary>
        public void SoftStop()
        {
            /* Send SoftStop operation code to dSPIN */
            WriteByte((byte)Commands.SOFT_STOP);
        }

        /// <summary>
        /// Hard stop operation
        /// </summary>
        public void HardStop()
        {
            /* Send HardStop operation code to dSPIN */
            WriteByte((byte)Commands.HARD_STOP);
        }

        /// <summary>
        /// TODO
        /// </summary>
        public void SoftHiZ()
        {
            /* Send SoftHiZ operation code to dSPIN */
            WriteByte((byte)Commands.SOFT_HIZ);
        }

        /// <summary>
        /// TODO
        /// </summary>
        public void HardHiZ()
        {
            /* Send HardHiZ operation code to dSPIN */
            WriteByte((byte)Commands.HARD_HIZ);
        }

        /// <summary>
        /// Gets the status
        /// </summary>
        /// <returns>Status</returns>
        public ushort GetStatus()
        {
            ushort temp = 0;
            ushort rx = 0;

            /* Send GetStatus operation code to dSPIN */
            WriteByte((byte)Commands.GET_STATUS);
            /* Send zero byte / receive MSByte from dSPIN */
            temp = WriteByte((byte)(0x00));
            temp = (ushort)(temp << 8);
            rx |= temp;
            /* Send zero byte / receive LSByte from dSPIN */
            temp = WriteByte((byte)(0x00));
            rx |= temp;
            return rx;
        }

        /// <summary>
        /// Returns if the hardware is busy
        /// </summary>
        /// <returns>If the hardware is busy</returns>
        public bool BusyHW()
        {
            if (busyPin.Read() == false) return true;
            else
                //if(!(GPIO_ReadInputDataBit(BUSY_Port, BUSY_Pin))) return 0x01;
                //else return 0x00;
                //spi.
                return false;
        }

        /// <summary>
        /// Returns if the software is busy
        /// </summary>
        /// <returns>If the hardware is busy</returns>
        public byte BusySW()
        {
            if (0 == (GetStatus() & (ushort)Status_Masks.STATUS_BUSY)) return 0x01;
            else return 0x00;
        }
        
        /// <summary>
        /// Action Options
        /// </summary>
        public enum Action
        {
            ACTION_RESET = ((byte)0x00),
            ACTION_COPY = ((byte)0x01)
        };

        /// <summary>
        /// Direction Options
        /// </summary>
        public enum Direction
        {
            FWD = ((byte)0x01),
            REV = ((byte)0x00)
        };

        /// <summary>
        /// Status Masks
        /// </summary>
        public enum Status_Masks
        {
            STATUS_HIZ = (((ushort)0x0001)),
            STATUS_BUSY = (((ushort)0x0002)),
            STATUS_SW_F = (((ushort)0x0004)),
            STATUS_SW_EVN = (((ushort)0x0008)),
            STATUS_DIR = (((ushort)0x0010)),
            STATUS_MOT_STATUS = (((ushort)0x0060)),
            STATUS_NOTPERF_CMD = (((ushort)0x0080)),
            STATUS_WRONG_CMD = (((ushort)0x0100)),
            STATUS_UVLO = (((ushort)0x0200)),
            STATUS_TH_WRN = (((ushort)0x0400)),
            STATUS_TH_SD = (((ushort)0x0800)),
            STATUS_OCD = (((ushort)0x1000)),
            STATUS_STEP_LOSS_A = (((ushort)0x2000)),
            STATUS_STEP_LOSS_B = (((ushort)0x4000)),
            STATUS_SCK_MOD = (((ushort)0x8000))
        };

        /// <summary>
        /// Registers
        /// </summary>
        public enum Registers
        {
            ABS_POS = ((byte)0x01),
            EL_POS = ((byte)0x02),
            MARK = ((byte)0x03),
            SPEED = ((byte)0x04),
            ACC = ((byte)0x05),
            DEC = ((byte)0x06),
            MAX_SPEED = ((byte)0x07),
            MIN_SPEED = ((byte)0x08),
            FS_SPD = ((byte)0x15),
            KVAL_HOLD = ((byte)0x09),
            KVAL_RUN = ((byte)0x0A),
            KVAL_ACC = ((byte)0x0B),
            KVAL_DEC = ((byte)0x0C),
            INT_SPD = ((byte)0x0D),
            ST_SLP = ((byte)0x0E),
            FN_SLP_ACC = ((byte)0x0F),
            FN_SLP_DEC = ((byte)0x10),
            K_THERM = ((byte)0x11),
            ADC_OUT = ((byte)0x12),
            OCD_TH = ((byte)0x13),
            STALL_TH = ((byte)0x14),
            STEP_MODE = ((byte)0x16),
            ALARM_EN = ((byte)0x17),
            CONFIG = ((byte)0x18),
            STATUS = ((byte)0x19),
            RESERVED_REG1 = ((byte)0x1A),
            RESERVED_REG2 = ((byte)0x1B)
        };

        /// <summary>
        /// Commands
        /// </summary>
        public enum Commands
        {
            NOP = ((byte)0x00),
            SET_PARAM = ((byte)0x00),
            GET_PARAM = ((byte)0x20),
            RUN = ((byte)0x50),
            STEP_CLOCK = ((byte)0x58),
            MOVE = ((byte)0x40),
            GO_TO = ((byte)0x60),
            GO_TO_DIR = ((byte)0x68),
            GO_UNTIL = ((byte)0x82),
            RELEASE_SW = ((byte)0x92),
            GO_HOME = ((byte)0x70),
            GO_MARK = ((byte)0x78),
            RESET_POS = ((byte)0xD8),
            RESET_DEVICE = ((byte)0xC0),
            SOFT_STOP = ((byte)0xB0),
            HARD_STOP = ((byte)0xB8),
            SOFT_HIZ = ((byte)0xA0),
            HARD_HIZ = ((byte)0xA8),
            GET_STATUS = ((byte)0xD0),
            RESERVED_CMD1 = ((byte)0xEB),
            RESERVED_CMD2 = ((byte)0xF8)
        };


        private void Regs_Struct_Reset(RegsStruct RegsStruct)
        {
            RegsStruct.ABS_POS = 0;
            RegsStruct.EL_POS = 0;
            RegsStruct.MARK = 0;
            RegsStruct.SPEED = 0;
            RegsStruct.ACC = 0x08A;
            RegsStruct.DEC = 0x08A;
            RegsStruct.MAX_SPEED = 0x041;
            RegsStruct.MIN_SPEED = 0;
            RegsStruct.FS_SPD = 0x027;
            RegsStruct.KVAL_HOLD = 0x29;
            RegsStruct.KVAL_RUN = 0x29;
            RegsStruct.KVAL_ACC = 0x29;
            RegsStruct.KVAL_DEC = 0x29;
            RegsStruct.INT_SPD = 0x0408;
            RegsStruct.ST_SLP = 0x19;
            RegsStruct.FN_SLP_ACC = 0x29;
            RegsStruct.FN_SLP_DEC = 0x29;
            RegsStruct.K_THERM = 0;
            RegsStruct.OCD_TH = 0x8;
            RegsStruct.STALL_TH = 0x40;
            RegsStruct.STEP_MODE = 0x7;
            RegsStruct.ALARM_EN = 0xFF;
            RegsStruct.CONFIG = 0x2E88;
        }

        /// <summary>
        /// Sets the registers to the passed in register values
        /// </summary>
        /// <param name="RegsStruct">Register values to set the values to</param>
        public void SetRegisters(RegsStruct RegsStruct)
        {
            SetParam(Registers.ABS_POS, RegsStruct.ABS_POS);
            SetParam(Registers.EL_POS, RegsStruct.EL_POS);
            SetParam(Registers.MARK, RegsStruct.MARK);
            SetParam(Registers.SPEED, RegsStruct.SPEED);
            SetParam(Registers.ACC, RegsStruct.ACC);
            SetParam(Registers.DEC, RegsStruct.DEC);
            SetParam(Registers.MAX_SPEED, RegsStruct.MAX_SPEED);
            SetParam(Registers.MIN_SPEED, RegsStruct.MIN_SPEED);
            SetParam(Registers.FS_SPD, RegsStruct.FS_SPD);
            SetParam(Registers.KVAL_HOLD, RegsStruct.KVAL_HOLD);
            SetParam(Registers.KVAL_RUN, RegsStruct.KVAL_RUN);
            SetParam(Registers.KVAL_ACC, RegsStruct.KVAL_ACC);
            SetParam(Registers.KVAL_DEC, RegsStruct.KVAL_DEC);
            SetParam(Registers.INT_SPD, RegsStruct.INT_SPD);
            SetParam(Registers.ST_SLP, RegsStruct.ST_SLP);
            SetParam(Registers.FN_SLP_ACC, RegsStruct.FN_SLP_ACC);
            SetParam(Registers.FN_SLP_DEC, RegsStruct.FN_SLP_DEC);
            SetParam(Registers.K_THERM, RegsStruct.K_THERM);
            SetParam(Registers.OCD_TH, RegsStruct.OCD_TH);
            SetParam(Registers.STALL_TH, RegsStruct.STALL_TH);
            SetParam(Registers.STEP_MODE, RegsStruct.STEP_MODE);
            SetParam(Registers.ALARM_EN, RegsStruct.ALARM_EN);
            SetParam(Registers.CONFIG, RegsStruct.CONFIG);
        }

        /// <summary>
        /// Overcurrent Detection Threshold Options
        /// </summary>
        public enum Overcurrent_Detection_Threshold
        {
            OCD_TH_375mA = ((byte)0x00),
            OCD_TH_750mA = ((byte)0x01),
            OCD_TH_1125mA = ((byte)0x02),
            OCD_TH_1500mA = ((byte)0x03),
            OCD_TH_1875mA = ((byte)0x04),
            OCD_TH_2250mA = ((byte)0x05),
            OCD_TH_2625mA = ((byte)0x06),
            OCD_TH_3000mA = ((byte)0x07),
            OCD_TH_3375mA = ((byte)0x08),
            OCD_TH_3750mA = ((byte)0x09),
            OCD_TH_4125mA = ((byte)0x0A),
            OCD_TH_4500mA = ((byte)0x0B),
            OCD_TH_4875mA = ((byte)0x0C),
            OCD_TH_5250mA = ((byte)0x0D),
            OCD_TH_5625mA = ((byte)0x0E),
            OCD_TH_6000mA = ((byte)0x0F)
        };

        /// <summary>
        /// Step Select Options
        /// </summary>
        public enum Step_Select
        {
            STEP_SEL_1 = ((byte)0x00),
            STEP_SEL_1_2 = ((byte)0x01),
            STEP_SEL_1_4 = ((byte)0x02),
            STEP_SEL_1_8 = ((byte)0x03),
            STEP_SEL_1_16 = ((byte)0x04),
            STEP_SEL_1_32 = ((byte)0x05),
            STEP_SEL_1_64 = ((byte)0x06),
            STEP_SEL_1_128 = ((byte)0x07)
        };

        /// <summary>
        /// Alarm Enable Options
        /// </summary>
        public enum Alarm_Enable
        {
            ALARM_EN_OVERCURRENT = ((byte)0x01),
            ALARM_EN_THERMAL_SHUTDOWN = ((byte)0x02),
            ALARM_EN_THERMAL_WARNING = ((byte)0x04),
            ALARM_EN_UNDER_VOLTAGE = ((byte)0x08),
            ALARM_EN_STALL_DET_A = ((byte)0x10),
            ALARM_EN_STALL_DET_B = ((byte)0x20),
            ALARM_EN_SW_TURN_ON = ((byte)0x40),
            ALARM_EN_WRONG_NPERF_CMD = ((byte)0x80)
        };

        /// <summary>
        /// Configuration Register Options
        /// </summary>
        public enum CONFIG_OSC_MGMT
        {
            CONFIG_INT_16MHZ = ((ushort)0x0000),
            CONFIG_INT_16MHZ_OSCOUT_2MHZ = ((ushort)0x0008),
            CONFIG_INT_16MHZ_OSCOUT_4MHZ = ((ushort)0x0009),
            CONFIG_INT_16MHZ_OSCOUT_8MHZ = ((ushort)0x000A),
            CONFIG_INT_16MHZ_OSCOUT_16MHZ = ((ushort)0x000B),
            CONFIG_EXT_8MHZ_XTAL_DRIVE = ((ushort)0x0004),
            CONFIG_EXT_16MHZ_XTAL_DRIVE = ((ushort)0x0005),
            CONFIG_EXT_24MHZ_XTAL_DRIVE = ((ushort)0x0006),
            CONFIG_EXT_32MHZ_XTAL_DRIVE = ((ushort)0x0007),
            CONFIG_EXT_8MHZ_OSCOUT_INVERT = ((ushort)0x000C),
            CONFIG_EXT_16MHZ_OSCOUT_INVERT = ((ushort)0x000D),
            CONFIG_EXT_24MHZ_OSCOUT_INVERT = ((ushort)0x000E),
            CONFIG_EXT_32MHZ_OSCOUT_INVERT = ((ushort)0x000F)
        };

        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_SW_MODE_TypeDef
        {
            CONFIG_SW_HARD_STOP = ((ushort)0x0000),
            CONFIG_SW_USER = ((ushort)0x0010)
        };

        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_F_PWM_DEC
        {
            CONFIG_PWM_MUL_0_625 = (((ushort)0x00) << 10),
            CONFIG_PWM_MUL_0_75 = (((ushort)0x01) << 10),
            CONFIG_PWM_MUL_0_875 = (((ushort)0x02) << 10),
            CONFIG_PWM_MUL_1 = (((ushort)0x03) << 10),
            CONFIG_PWM_MUL_1_25 = (((ushort)0x04) << 10),
            CONFIG_PWM_MUL_1_5 = (((ushort)0x05) << 10),
            CONFIG_PWM_MUL_1_75 = (((ushort)0x06) << 10),
            CONFIG_PWM_MUL_2 = (((ushort)0x07) << 10)
        };
        
        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_F_PWM_INT
        {
            CONFIG_PWM_DIV_1 = (((ushort)0x00) << 13),
            CONFIG_PWM_DIV_2 = (((ushort)0x01) << 13),
            CONFIG_PWM_DIV_3 = (((ushort)0x02) << 13),
            CONFIG_PWM_DIV_4 = (((ushort)0x03) << 13),
            CONFIG_PWM_DIV_5 = (((ushort)0x04) << 13),
            CONFIG_PWM_DIV_6 = (((ushort)0x05) << 13),
            CONFIG_PWM_DIV_7 = (((ushort)0x06) << 13)
        };

        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_POW_SR
        {
            CONFIG_SR_180V_us = ((ushort)0x0000),
            CONFIG_SR_290V_us = ((ushort)0x0200),
            CONFIG_SR_530V_us = ((ushort)0x0300)
        };

        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_EN_VSCOMP
        {
            CONFIG_VS_COMP_DISABLE = ((ushort)0x0000),
            CONFIG_VS_COMP_ENABLE = ((ushort)0x0020)
        };

        /// <summary>
        /// TODO
        /// </summary>
        public enum CONFIG_OC_SD
        {
            CONFIG_OC_SD_DISABLE = ((ushort)0x0000),
            CONFIG_OC_SD_ENABLE = ((ushort)0x0080)
        };


        public uint Speed_Steps_to_Par(uint steps)
        {
            return ((uint)(((steps) * 67.108864) + 0.5));
        }
        public ushort AccDec_Steps_to_Par(uint steps)
        {
            return ((ushort)(((steps) * 0.068719476736) + 0.5));
        }
        public ushort MaxSpd_Steps_to_Par(uint steps)
        {
            return ((ushort)(((steps) * 0.065536) + 0.5));
        }
        public ushort MinSpd_Steps_to_Par(uint steps)
        {
            return ((ushort)(((steps) * 4.194304) + 0.5));
        }
        public ushort FSSpd_Steps_to_Par(uint steps)
        {
            return (ushort)(((steps) * 0.065536));
        }
        public ushort IntSpd_Steps_to_Par(uint steps)
        {
            return ((ushort)(((steps) * 4.194304) + 0.5));
        }
        public byte Kval_Perc_to_Par(float perc)
        {
            return ((byte)(((perc) / 0.390625) + 0.5));
        }
        public byte BEMF_Slope_Perc_to_Par(float perc)
        {
            return ((byte)(((perc) / 0.00156862745098) + 0.5));
        }
        public byte KTherm_to_Par(uint KTherm)
        {
            return ((byte)(((KTherm - 1) / 0.03125) + 0.5));
        }
        public byte StallTh_to_Par(uint StallTh)
        {
            return ((byte)(((StallTh - 31.25) / 31.25) + 0.5));
        }
    } 

    /// <summary>
    /// Avalilable Registers
    /// </summary>
    public class RegsStruct
    {
        /// <summary>
        /// Empty Constructor
        /// </summary>
        public RegsStruct()
        {
            //
        }
        public uint ABS_POS;
        public ushort EL_POS;
        public uint MARK;
        public uint SPEED;
        public ushort ACC;
        public ushort DEC;
        public ushort MAX_SPEED;
        public ushort MIN_SPEED;
        public ushort FS_SPD;
        public byte KVAL_HOLD;
        public byte KVAL_RUN;
        public byte KVAL_ACC;
        public byte KVAL_DEC;
        public ushort INT_SPD;
        public byte ST_SLP;
        public byte FN_SLP_ACC;
        public byte FN_SLP_DEC;
        public byte K_THERM;
        public byte ADC_OUT;
        public byte OCD_TH;
        public byte STALL_TH;
        public byte STEP_MODE;
        public byte ALARM_EN;
        public ushort CONFIG;
    }
}
