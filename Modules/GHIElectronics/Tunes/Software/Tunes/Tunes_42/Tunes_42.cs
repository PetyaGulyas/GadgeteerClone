using System;
using Microsoft.SPOT;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;
using System.Collections;

using System.Threading;

namespace Gadgeteer.Modules.GHIElectronics
{
    // -- CHANGE FOR MICRO FRAMEWORK 4.2 --
    // If you want to use Serial, SPI, or DaisyLink (which includes GTI.SoftwareI2C), you must do a few more steps
    // since these have been moved to separate assemblies for NETMF 4.2 (to reduce the minimum memory footprint of Gadgeteer)
    // 1) add a reference to the assembly (named Gadgeteer.[interfacename])
    // 2) in GadgeteerHardware.xml, uncomment the lines under <Assemblies> so that end user apps using this module also add a reference.

    /// <summary>
    /// A Tunes module for Microsoft .NET Gadgeteer
    /// </summary>
    public class Tunes : GTM.Module
    {
        private GT.Interfaces.PWMOutput tunePWM;
        private Queue playList;

        /// <summary>
        /// Class that holds and manages notes that can be played.
        /// </summary>
        public class Tone
        {
            /// <summary>
            /// Frequency of the note in hertz
            /// </summary>
            public double freq;

            private Tone(double freq)
            {
                this.freq = freq;
            }

            /// <summary>
            /// A "rest" note, or a silent note.
            /// </summary>
            public static readonly Tone Rest = new Tone(0.0);

            #region 4th Octave
            /// <summary>
            /// C in the 4th octave. Middle C.
            /// </summary>
            public static readonly Tone C4 = new Tone(261.626);

            /// <summary>
            /// D in the 4th octave.
            /// </summary>
            public static readonly Tone D4 = new Tone(293.665);

            /// <summary>
            /// E in the 4th octave.
            /// </summary>
            public static readonly Tone E4 = new Tone(329.628);

            /// <summary>
            /// F in the 4th octave.
            /// </summary>
            public static readonly Tone F4 = new Tone(349.228);

            /// <summary>
            /// G in the 4th octave.
            /// </summary>
            public static readonly Tone G4 = new Tone(391.995);

            /// <summary>
            /// A in the 4th octave.
            /// </summary>
            public static readonly Tone A4 = new Tone(440);

            /// <summary>
            /// B in the 4th octave.
            /// </summary>
            public static readonly Tone B4 = new Tone(493.883);

            #endregion 4th Octave

            #region 5th Octave

            /// <summary>
            /// C in the 5th octave.
            /// </summary>
            public static readonly Tone C5 = new Tone(523.251);

            #endregion 5th Octave
        }

        /// <summary>
        /// Class that describes a musical note, containing a tone and a duration.
        /// </summary>
        public class MusicNote
        {
            public Tone tone;
            public int duration;

            /// <summary>
            /// Constructor
            /// </summary>
            /// <param name="tone">The tone of the note.</param>
            /// <param name="duration">The duration that the note should be played.</param>
            public MusicNote(Tone tone, int duration)
            {
                this.tone = tone;
                this.duration = duration;
            }
        }

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public Tunes(int socketNumber)
        {
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);

            socket.EnsureTypeIsSupported('P', this);

            tunePWM = new GTI.PWMOutput(socket, Socket.Pin.Nine, false, this);

            playList = new Queue();
            playList.Clear();
        }

        // Determines if the module is currently iterating through the queue and playing notes.
        private bool bIsPlaying = false;

        // Determines if playback should stop. False if there is no need to stop. When set to True, playback is stopped and this value is toggled back to False once playback is over. 
        private bool bStopAcknowledged = false;

        private Thread playbackThread;

        /// <summary>
        /// Starts note playback. Returns if it made any change.
        /// </summary>
        /// <returns>Returns true if notes were not playing and they were started. False if notes were already being played.</returns>
        public bool Play()
        {
            // Make sure the queue is not empty and we are not currently playing it.
            if (!bIsPlaying && playList.Count > 0)
            {
                bIsPlaying = true;
                bStopAcknowledged = false;

                playbackThread = new Thread(playbackThreadStart);
                playbackThread.Start();

                return true;
            }
            else
            {
                // We can do nothing. It is already running.
                return false;
            }
        }

        /// <summary>
        /// The function that runs when the playback thread is started. Returns (ends the thread) when playback is finished or Stop() is called.
        /// </summary>
        void playbackThreadStart()
        {
            while (playList.Count > 0)
            {
                if (bStopAcknowledged)
                {
                    bStopAcknowledged = false;
                    break;
                }

                // Get the next note.
                MusicNote currNote = (MusicNote)playList.Dequeue();

                // Set the tone and sleep for the duration
                SetTone(currNote.tone);

                Thread.Sleep(currNote.duration);
            }

            SetTone(Tone.Rest);
            bIsPlaying = false;
        }

        /// <summary>
        ///  Sets PWM to the tone frequency and starts it.
        /// </summary>
        /// <param name="tone"></param>
        private void SetTone(Tone tone)
        {
            tunePWM.Active = false;

            if (tone == Tone.Rest)
                return;

            tunePWM.Set((int)tone.freq, 0.5);
            tunePWM.Active = true;
        }

        /// <summary>
        /// Stops note playback. Returns if it made any change.
        /// </summary>
        /// <returns>Returns true if notes were playing and they were stopped. False if playback was already stopped.</returns>
        public bool Stop()
        {
            if (bIsPlaying)
            {
                bStopAcknowledged = true;

                return true;
            }
            else
            {
                // We can do nothing. It is already stopped.
                return false;
            }
        }

        /// <summary>
        /// Adds a note to the queue to be played
        /// </summary>
        /// <param name="note">The note to be added, which describes the tone and duration to be played.</param>
        public void AddNote(MusicNote note)
        {
            playList.Enqueue(note);
        }

    }
}
