using System;
using System.Threading;
using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.SocketInterfaces;

namespace Gadgeteer.Modules.GHIElectronics
{
    /// <summary>
    /// A Barometer Gadgeteer module, based on the Hope RF HP03M pressure sensor module.
    /// </summary>
    public class Barometer : GTM.Module
    {

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public Barometer(int socketNumber)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);

            this.XCLR = GTI.DigitalOutputFactory.Create(socket, Socket.Pin.Three, false, this);

            ReadFactoryCalibrationData(socket);
            i2c = GTI.I2CBusFactory.Create(socket, ADC_ADDRESS, 100, this); //  EE = ADC write Address, 0xEE >> 1 = 0x77, 0xA1 = EEProm, 0xEE >> 1 = 0x50

            continuousTimer = new Gadgeteer.Timer(new TimeSpan(0, 0, 0, 0, 200));
            continuousTimer.Tick += new Timer.TickEventHandler(continuousTimer_Tick);
        }

        private GTI.I2CBus i2c;
        private GTI.DigitalOutput XCLR;

        private Coefficients Coeff;

        static ushort ADC_ADDRESS = 0x77;
        static ushort EEPROM_ADDR = 0x50;

        private GT.Timer continuousTimer;
        private bool continuousMeasurement = false;

        private enum Register : byte
        {
            COEFF = 0x10,
            DATD1 = 0xFF,
            DATD2 = 0xF0
        }

        private byte[] _readBuffer8 = new byte[1];
        private byte[] _writeBuffer8 = new byte[1];

        private byte[] _readBuffer16 = new byte[2];
        private byte[] _readBuffer144 = new byte[18];

        private struct Coefficients
        {
            public int C1, C2, C3, C4, C5, C6, C7;
            public int A, B, C, D;
        }


        // This reads the calibration data stored in the onboard EEPROM
        // Needs only to be done once, on initialization.
        private void ReadFactoryCalibrationData(Gadgeteer.Socket socket)
        {
            GTI.I2CBus eeprom_i2c = GTI.I2CBusFactory.Create(socket, EEPROM_ADDR, 100, this);

            XCLR.Write(false);
            Coeff = new Coefficients();
            Read(eeprom_i2c, Register.COEFF, _readBuffer144);
            Coeff.C1 = (_readBuffer144[0] << 8) + _readBuffer144[1];
            Coeff.C2 = (_readBuffer144[2] << 8) + _readBuffer144[3];
            Coeff.C3 = (_readBuffer144[4] << 8) + _readBuffer144[5];
            Coeff.C4 = (_readBuffer144[6] << 8) + _readBuffer144[7];
            Coeff.C5 = (_readBuffer144[8] << 8) + _readBuffer144[9];
            Coeff.C6 = (_readBuffer144[10] << 8) + _readBuffer144[11];
            Coeff.C7 = (_readBuffer144[12] << 8) + _readBuffer144[13];
            Coeff.A = _readBuffer144[14];
            Coeff.B = _readBuffer144[15];
            Coeff.C = _readBuffer144[16];
            Coeff.D = _readBuffer144[17];

        }

        private void Read(GTI.I2CBus i2c, Register register, byte[] readBuffer)
        {
            _writeBuffer8[0] = (byte)register;
            int ack = i2c.WriteRead(_writeBuffer8, readBuffer);
        }

        /// <summary>
        /// Obtains a single measurement from the <see cref="Barometer"/> and raises the <see cref="MeasurementComplete"/> event when complete.
        /// </summary>
        public void RequestMeasurement()
        {
            double dUT, OFF, SENS, X;
            double P, T;
            int D1, D2;

            /////////////////////////////////////////////////////////
            // Read the data
            /////////////////////////////////////////////////////////

            // Pull xCLR High
            XCLR.Write(true);

            // Get raw pressure value
            int ack = i2c.Write(new byte[] { 0xFF, 0xF0 });
            Thread.Sleep(40);
            ack = i2c.WriteRead(new byte[] { 0xFD }, _readBuffer16);

            D1 = (_readBuffer16[0] << 8) | _readBuffer16[1];

            // Get raw temperature value
            ack = i2c.Write(new byte[] { 0xFF, 0xE8 });
            Thread.Sleep(40);
            ack = i2c.WriteRead(new byte[] { 0xFD }, _readBuffer16);

            D2 = (_readBuffer16[0] << 8) | _readBuffer16[1];

            // pull low
            XCLR.Write(false);


            ////////////////////////////////////////////////////////////////
            // Calculate temperature and pressure based on calibration data
            ////////////////////////////////////////////////////////////////

            // Step 1. Get temperature value.

            // D2 >= C5 dUT= D2-C5 - ((D2-C5)/2^7) * ((D2-C5)/2^7) * A / 2^C
            if (D2 >= Coeff.C5)
            {
                dUT = D2 - Coeff.C5 - ((D2 - Coeff.C5) / System.Math.Pow(2, 7) * ((D2 - Coeff.C5) / System.Math.Pow(2, 7)) * Coeff.A / System.Math.Pow(2, Coeff.C));
            }
            // D2 <  C5 dUT= D2-C5 - ((D2-C5)/2^7) * ((D2-C5)/2^7) * B / 2^C
            else
            {
                dUT = D2 - Coeff.C5 - ((D2 - Coeff.C5) / System.Math.Pow(2, 7) * ((D2 - Coeff.C5) / System.Math.Pow(2, 7)) * Coeff.B / System.Math.Pow(2, Coeff.C));
            }

            // Step 2. Calculate offset, sensitivity and final pressure value.

            // OFF=(C2+(C4-1024)*dUT/2^14)*4
            OFF = (Coeff.C2 + (Coeff.C4 - 1024) * dUT / System.Math.Pow(2, 14)) * 4;
            // SENS = C1+ C3*dUT/2^10
            SENS = Coeff.C1 + Coeff.C3 * dUT / System.Math.Pow(2, 10);
            // X= SENS * (D1-7168)/2^14 - OFF
            X = SENS * (D1 - 7168) / System.Math.Pow(2, 14) - OFF;
            // P=X*10/2^5+C7
            P = X * 10 / System.Math.Pow(2, 5) + Coeff.C7;

            // Step 3. Calculate temperature

            // T = 250 + dUT * C6 / 2 ^ 16-dUT/2^D
            T = 250 + dUT * Coeff.C6 / System.Math.Pow(2, 16) - dUT / System.Math.Pow(2, Coeff.D);


            SensorData sensData = new SensorData(T / 10, P / 10);
            OnMeasurementCompleteEvent(this, sensData);
        }


        /// <summary>
        /// Starts continuous measurements.
        /// </summary>
        /// <remarks>
        /// When this method is called, the <see cref="Barometer"/> begins taking continuous measurements.
        /// At each <see cref="ContinuousMeasurementInterval"/>, it calls the <see cref="RequestMeasurement"/> method,
        /// which raises the <see cref="MeasurementComplete"/> event.
        /// </remarks>
        public void StartContinuousMeasurements()
        {
            continuousMeasurement = true;
            continuousTimer.Start();
        }

        /// <summary>
        /// Stops continuous measurements.
        /// </summary>
        public void StopContinuousMeasurements()
        {
            continuousMeasurement = false;
            continuousTimer.Stop();
        }

        /// <summary>
        /// Gets or sets the interval at which continuous measurements are taken.
        /// </summary>
        /// <remarks>
        /// The default value for this property is 200 milliseconds.
        /// </remarks>
        public TimeSpan ContinuousMeasurementInterval
        {
            get
            {
                return continuousTimer.Interval;
            }
            set
            {
                continuousTimer.Stop();
                continuousTimer.Interval = value;
                if (continuousMeasurement) continuousTimer.Start();
            }
        }


        private void continuousTimer_Tick(Timer timer)
        {
            if (!continuousMeasurement)
            {
                timer.Stop();
                return;
            }
            RequestMeasurement();
        }

        /// <summary>
        /// 
        /// </summary>
        public class SensorData
        {
            /// <summary>
            /// The sensed temperature, in degrees Celsius.
            /// </summary>
            public double Temperature { get; private set; }
            /// <summary>
            /// The sensed atmospheric pressure, in hectopascals.
            /// </summary>
            public double Pressure { get; private set; }

            /// <summary>
            /// A sensor reading, containing temperature and pressure measurements.
            /// </summary>
            /// <param name="temperature">The sensed temperature, in degrees Celsius.</param>
            /// <param name="pressure">The sensed atmospheric pressure, in hectopascals.</param>
            public SensorData(double temperature, double pressure)
            {
                this.Temperature = temperature;
                this.Pressure = pressure;
            }

            /// <summary>
            /// Provides a string representation of the <see cref="SensorData"/> instance.
            /// </summary>
            /// <returns>A string describing the values contained in the object.</returns>
            public override string ToString()
            {
                return "Temperature: " + Temperature.ToString("f2") + " degrees Celsius. Pressure: " + Pressure.ToString("f2") + " hPa.";
            }
        }

        /// <summary>
        /// Represents the delegate used for the <see cref="MeasurementComplete"/> event.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="sensorData">The <see cref="SensorData"/> object that contains the results of the measurement.</param>
        public delegate void MeasurementCompleteEventHandler(Barometer sender, SensorData sensorData);

        /// <summary>
        /// Event raised when a measurement reading is completed.
        /// </summary>
        public event MeasurementCompleteEventHandler MeasurementComplete;

        private MeasurementCompleteEventHandler _OnMeasurementComplete;

        /// <summary>
        /// Raises the <see cref="MeasurementComplete"/> event.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="sensorData">The <see cref="SensorData"/> object that contains the results of the measurement.</param>
        protected virtual void OnMeasurementCompleteEvent(Barometer sender, SensorData sensorData)
        {
            if (_OnMeasurementComplete == null) _OnMeasurementComplete = new MeasurementCompleteEventHandler(OnMeasurementCompleteEvent);
            if (Program.CheckAndInvoke(MeasurementComplete, _OnMeasurementComplete, sender, sensorData))
            {
                MeasurementComplete(sender, sensorData);
            }
        }

    }
}
