using System;
using Microsoft.SPOT;

using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;

namespace Gadgeteer.Modules.GHIElectronics
{
    // -- CHANGE FOR MICRO FRAMEWORK 4.2 --
    // If you want to use Serial, SPI, or DaisyLink (which includes GTI.SoftwareI2C), you must do a few more steps
    // since these have been moved to separate assemblies for NETMF 4.2 (to reduce the minimum memory footprint of Gadgeteer)
    // 1) add a reference to the assembly (named Gadgeteer.[interfacename])
    // 2) in GadgeteerHardware.xml, uncomment the lines under <Assemblies> so that end user apps using this module also add a reference.

    /// <summary>
    /// A VGA and Analog Video output module for Microsoft .NET Gadgeteer
    /// </summary>
    /// <example>
    /// <para>The following example shows how to set the display configuration and render to the screen.</para>
    ///  <code>
    /// using System;
    /// using System.Threading;
    /// using Microsoft.SPOT;
    /// using Microsoft.SPOT.Presentation;
    /// using Microsoft.SPOT.Presentation.Controls;
    /// using Microsoft.SPOT.Presentation.Media;
    /// using Microsoft.SPOT.Touch;
    ///
    /// using Gadgeteer.Networking;
    /// using GT = Gadgeteer;
    /// using GTM = Gadgeteer.Modules;
    /// using Gadgeteer.Modules.GHIElectronics;
    ///
    /// namespace TestApp
    /// {
    ///     public partial class Program
    ///     {
    ///         void ProgramStarted()
    ///         {
    ///             video_Out.SetDisplayConfiguration(Video_Out.Video_Out_InputResolution.Output_800x600_VGA);
    ///
    ///             video_Out.SimpleGraphics.AutoRedraw = true;
    ///
    ///             video_Out.SimpleGraphics.DisplayText("Test Text", Resources.GetFont(Resources.FontResources.NinaB), GT.Color.Red, 10, 10);
    ///         }
    ///     }
    /// }
    ///  </code>
    /// </example>
    public class Video_Out : GTM.Module.DisplayModule
    {
        //private static GT.Interfaces.I2CBus i2cBus2;
        private static GT.Interfaces.SoftwareI2C softwareI2C;

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <remarks>The ordering of the RGB socket numbers does not matter (socket numbers are autodetected)</remarks> 
        /// <param name="rgbSocketNumber1">The mainboard socket that has the display's R, G, or B socket connected to it.</param>
        /// <param name="rgbSocketNumber2">The mainboard socket that has the display's R, G, or B socket connected to it.</param>
        /// <param name="rgbSocketNumber3">The mainboard socket that has the display's R, G, or B socket connected to it.</param>
        /// <param name="i2cSocketNumber">The mainboard socket that has the display's X socket connected to it.</param>
        public Video_Out(int rgbSocketNumber1, int rgbSocketNumber2, int rgbSocketNumber3, int i2cSocketNumber)
            : base(WPFRenderOptions.Ignore)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            //Socket socket = Socket.GetSocket(socketNumber, true, this, null);
            ReserveLCDPins(rgbSocketNumber1, rgbSocketNumber2, rgbSocketNumber3);

            Socket i2cSocket = Socket.GetSocket(i2cSocketNumber, true, this, null);
            i2cSocket.EnsureTypeIsSupported(new char[] { 'X', 'Y' }, this);

            //i2cBus2 = new GTI.I2CBus(i2cSocket, DEVICE_ADDR, 100, this);
            softwareI2C = new GTI.SoftwareI2C(i2cSocket, Socket.Pin.Five, Socket.Pin.Four, this);
        }

        private const byte DEVICE_ADDR = 0X76;

        private static uint m_currWidth = 320;
        private static uint m_currHeight = 240;

        private void ReserveLCDPins(int rgbSocketNumber1, int rgbSocketNumber2, int rgbSocketNumber3)
        {
            bool gotR = false, gotG = false, gotB = false;
            Socket[] rgbSockets = new Socket[3] { Socket.GetSocket(rgbSocketNumber1, true, this, "rgbSocket1"), Socket.GetSocket(rgbSocketNumber2, true, this, "rgbSocket2"), Socket.GetSocket(rgbSocketNumber3, true, this, "rgbSocket3") };

            foreach (var rgbSocket in rgbSockets)
            {
                if (!gotR && rgbSocket.SupportsType('R'))
                {
                    gotR = true;
                }
                else if (!gotG && rgbSocket.SupportsType('G'))
                {
                    gotG = true;
                }
                else if (!gotB && rgbSocket.SupportsType('B'))
                {
                    gotB = true;
                }
                else
                {
                    throw new GT.Socket.InvalidSocketException("Socket " + rgbSocket + " is not an R, G or B socket, as required for the LCD module.");
                }

                rgbSocket.ReservePin(Socket.Pin.Three, this);
                rgbSocket.ReservePin(Socket.Pin.Four, this);
                rgbSocket.ReservePin(Socket.Pin.Five, this);
                rgbSocket.ReservePin(Socket.Pin.Six, this);
                rgbSocket.ReservePin(Socket.Pin.Seven, this);
                rgbSocket.ReservePin(Socket.Pin.Eight, this);
                rgbSocket.ReservePin(Socket.Pin.Nine, this);

            }
        }

        /// <summary>
        /// Represents the input resolution of the <see cref="Video_Out"/> object.
        /// </summary>
        public enum Video_Out_InputResolution
        {
            /// <summary>
            /// Represents the values for an RCA display in the NTSC standard with a resolution of 320x240.
            /// </summary>
            Output_320x240_RCA = 0,

            /// <summary>
            /// Represents the values for an RCA display in the NTSC standard with a resolution of 640x480.
            /// </summary>
            Output_640x480_RCA = 1,

            /// <summary>
            /// Represents the values for an RCA display in the NTSC standard with a resolution of 800x600.
            /// </summary>
            Output_800x600_RCA = 2,

            /// <summary>
            /// Represents the values for an VGA display with a resolution of 320x240.
            /// </summary>
            Output_320x240_VGA = 10,

            /// <summary>
            /// Represents the values for an VGA display with a resolution of 640x480.
            /// </summary>
            Output_640x480_VGA = 11,

            /// <summary>
            /// Represents the values for an VGA display with a resolution of 800x600.
            /// </summary>
            Output_800x600_VGA = 12,

            /// <summary>
            /// Represents the values for an RCA display in the PAL standard with a resolution of 320x240.
            /// </summary>
            Output_320x240_RCA_PAL = 20
        }

        /// <summary>
        /// Selects a resolution based on the passed in value, and sets the mainboard's display configuration and the proper registers
        /// for the module to match the mainboard's display configuration.
        /// </summary>
        /// <remarks>NOTE: Any time the mainboard display configuration is changed, the board will have to reset to apply the changes. 
        /// If the same resolution is selected (320x240 RCA to 320x240 VGA) the board will not need to reset.</remarks>
        /// <param name="res">The desired output type and resolution.</param>
        public void SetDisplayConfiguration(Video_Out_InputResolution res)
        {
            Mainboard.LCDConfiguration lcdConfig = new Mainboard.LCDConfiguration();
            lcdConfig.LCDControllerEnabled = true;
            lcdConfig.PriorityEnable = true;

            switch (res)
            {
                #region 320_240_RCA
                case Video_Out_InputResolution.Output_320x240_RCA:
                    {
                        lcdConfig.Width = m_currWidth = 320;
                        lcdConfig.Height = m_currHeight = 240;
                        Write320x240RCARegisters();
                        break;
                    }
                #endregion
                #region 640_480_RCA
                case Video_Out_InputResolution.Output_640x480_RCA:
                    {
                        lcdConfig.Width = m_currWidth = 640;
                        lcdConfig.Height = m_currHeight = 480;
                        Write640x480RCARegisters();
                        break;
                    }
                #endregion
                #region 800_600_RCA
                case Video_Out_InputResolution.Output_800x600_RCA:
                    {
                        lcdConfig.Width = m_currWidth = 800;
                        lcdConfig.Height = m_currHeight = 600;
                        Write800x600RCARegisters();
                        break;
                    }
                #endregion
                #region 320_240_VGA
                case Video_Out_InputResolution.Output_320x240_VGA:
                    {
                        lcdConfig.Width = m_currWidth = 320;
                        lcdConfig.Height = m_currHeight = 240;
                        Write320x240VGARegisters();
                        break;
                    }
                #endregion
                #region 640_480_VGA
                case Video_Out_InputResolution.Output_640x480_VGA:
                    {
                        lcdConfig.Width = m_currWidth = 640;
                        lcdConfig.Height = m_currHeight = 480;
                        Write640x480VGARegisters();
                        break;
                    }
                #endregion
                #region 800_600_VGA
                case Video_Out_InputResolution.Output_800x600_VGA:
                    {
                        lcdConfig.Width = m_currWidth = 800;
                        lcdConfig.Height = m_currHeight = 600;
                        Write800x600VGARegisters();
                        break;
                    }
                #endregion
                case Video_Out_InputResolution.Output_320x240_RCA_PAL:
                    {
                        lcdConfig.Width = m_currWidth = 320;
                        lcdConfig.Height = m_currHeight = 240;
                        Write320x240VGAPALRegisters();
                        break;
                    }
            }

            lcdConfig.OutputEnableIsFixed = false;
            lcdConfig.OutputEnablePolarity = false;
            lcdConfig.HorizontalSyncPolarity = true;
            lcdConfig.VerticalSyncPolarity = true;
            lcdConfig.PixelPolarity = false;
            lcdConfig.HorizontalSyncPulseWidth = 10;
            lcdConfig.HorizontalBackPorch = 10;
            lcdConfig.HorizontalFrontPorch = 10;
            lcdConfig.VerticalSyncPulseWidth = 10;
            lcdConfig.VerticalBackPorch = 10;
            lcdConfig.VerticalFrontPorch = 10;

            // NOTE: This is used for EMX
            lcdConfig.PixelClockDivider = 8;

            // Set config
            DisplayModule.SetLCDConfig(lcdConfig);

            const int CH7025_DID = 0x55;
            const int CH7026_DID = 0x54;

            System.Threading.Thread.Sleep(1000);

            byte ud = I2CRead(0x00);
            if ((ud != CH7025_DID) && (ud != CH7026_DID))
            {
                throw new Exception();// 1; // CH7025/26B was not found
            }
        }

        private static void I2Cwrite(byte address, byte data)
        {
            I2CWrite(address, data);
        }

        private static void I2CWrite(byte address, byte data)
        {
            byte[] Write_buffer = new byte[2] { address, data };

            softwareI2C.Write(DEVICE_ADDR, Write_buffer);
            //i2cBus2.Write(write_buffer, 1000);
        }

        private void Write320x240RCARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x0A, 0x10);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0D, 0x80);
            I2CWrite(0x11, 0x5E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x17, 0x0E);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x04);
            I2CWrite(0x4E, 0x80);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x1B);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x71);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x70);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x30);
        }

        private void Write640x480RCARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x0A, 0x10);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0F, 0x12);
            I2CWrite(0x10, 0x80);
            I2CWrite(0x11, 0x9E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x15, 0x09);
            I2CWrite(0x16, 0xE0);
            I2CWrite(0x17, 0xFE);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x04);
            I2CWrite(0x4E, 0x80);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x1B);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x71);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x70);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x30);
        }

        private void Write800x600RCARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x06, 0x6B);
            I2CWrite(0x0A, 0x10);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0F, 0x1B);
            I2CWrite(0x10, 0x20);
            I2CWrite(0x11, 0x3E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x15, 0x12);
            I2CWrite(0x16, 0x58);
            I2CWrite(0x17, 0x76);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x04);
            I2CWrite(0x4E, 0x80);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x1B);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x69, 0x64);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x69);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x68);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x30);
        }

        private void Write320x240VGARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x08, 0x08);
            I2CWrite(0x09, 0x80);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0D, 0x88);
            I2CWrite(0x11, 0x5E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x17, 0x0E);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x1B, 0x23);
            I2CWrite(0x1C, 0x20);
            I2CWrite(0x1D, 0x20);
            I2CWrite(0x1F, 0x28);
            I2CWrite(0x20, 0x80);
            I2CWrite(0x21, 0x12);
            I2CWrite(0x22, 0x58);
            I2CWrite(0x23, 0x74);
            I2CWrite(0x25, 0x01);
            I2CWrite(0x26, 0x04);
            I2CWrite(0x37, 0x20);
            I2CWrite(0x39, 0x20);
            I2CWrite(0x3B, 0x20);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x03);
            I2CWrite(0x4E, 0x50);
            I2CWrite(0x4F, 0xDA);
            I2CWrite(0x50, 0x74);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x13);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x71);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x70);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x00);
        }

        private void Write640x480VGARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x08, 0x08);
            I2CWrite(0x09, 0x80);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0D, 0x08);
            I2CWrite(0x0F, 0x12);
            I2CWrite(0x10, 0x80);
            I2CWrite(0x11, 0x9E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x15, 0x09);
            I2CWrite(0x16, 0xE0);
            I2CWrite(0x17, 0xFE);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x1B, 0x23);
            I2CWrite(0x1C, 0x20);
            I2CWrite(0x1D, 0x20);
            I2CWrite(0x1F, 0x28);
            I2CWrite(0x20, 0x80);
            I2CWrite(0x21, 0x12);
            I2CWrite(0x22, 0x58);
            I2CWrite(0x23, 0x74);
            I2CWrite(0x25, 0x01);
            I2CWrite(0x26, 0x04);
            I2CWrite(0x37, 0x20);
            I2CWrite(0x39, 0x20);
            I2CWrite(0x3B, 0x20);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x03);
            I2CWrite(0x4E, 0x50);
            I2CWrite(0x4F, 0xDA);
            I2CWrite(0x50, 0x74);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x13);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x71);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x70);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x00);
        }

        private void Write800x600VGARegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x06, 0x6B);
            I2CWrite(0x08, 0x08);
            I2CWrite(0x09, 0x80);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0D, 0x08);
            I2CWrite(0x0F, 0x1B);
            I2CWrite(0x10, 0x20);
            I2CWrite(0x11, 0x3E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x15, 0x12);
            I2CWrite(0x16, 0x58);
            I2CWrite(0x17, 0x76);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x1B, 0x23);
            I2CWrite(0x1C, 0x20);
            I2CWrite(0x1D, 0x20);
            I2CWrite(0x1F, 0x28);
            I2CWrite(0x20, 0x80);
            I2CWrite(0x21, 0x12);
            I2CWrite(0x22, 0x58);
            I2CWrite(0x23, 0x74);
            I2CWrite(0x25, 0x01);
            I2CWrite(0x26, 0x04);
            I2CWrite(0x37, 0x20);
            I2CWrite(0x39, 0x20);
            I2CWrite(0x3B, 0x20);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x03);
            I2CWrite(0x4E, 0x50);
            I2CWrite(0x4F, 0xDA);
            I2CWrite(0x50, 0x74);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x13);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x69, 0x64);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x69);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x68);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x00);
        }

        private void Write320x240VGAPALRegisters()
        {
            I2CWrite(0x02, 0x01);
            I2CWrite(0x02, 0x03);
            I2CWrite(0x03, 0x00);
            I2CWrite(0x04, 0x39);
            I2CWrite(0x0A, 0x10);
            I2CWrite(0x0C, 0xD2);
            I2CWrite(0x0D, 0x84);
            I2CWrite(0x11, 0x5E);
            I2CWrite(0x12, 0x40);
            I2CWrite(0x13, 0x0A);
            I2CWrite(0x14, 0x0A);
            I2CWrite(0x17, 0x0E);
            I2CWrite(0x19, 0x0A);
            I2CWrite(0x1A, 0x0A);
            I2CWrite(0x41, 0x9A);
            I2CWrite(0x4D, 0x04);
            I2CWrite(0x4E, 0x80);
            I2CWrite(0x51, 0x4B);
            I2CWrite(0x52, 0x12);
            I2CWrite(0x53, 0x1B);
            I2CWrite(0x55, 0xE5);
            I2CWrite(0x5E, 0x80);
            I2CWrite(0x77, 0x03);
            I2CWrite(0x7D, 0x62);
            I2CWrite(0x04, 0x38);
            I2Cwrite(0x06, 0x71);

            /*
            NOTE: The following five repeated sentences are used here to wait memory initial complete, please don't remove...(you could refer to Appendix A of programming guide document (CH7025(26)B Programming Guide Rev2.03.pdf or later version) for detailed information about memory initialization! 
            */
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);
            I2Cwrite(0x03, 0x00);

            I2CWrite(0x06, 0x70);
            I2Cwrite(0x02, 0x02);
            I2Cwrite(0x02, 0x03);
            I2Cwrite(0x04, 0x30);
        }

        private static byte I2CRead(byte address)
        {
            byte[] Write_buffer = new byte[1] { address };
            byte[] Read_buffer = new byte[1];

            //i2cBus2.Read(read_buffer, 1000);
            softwareI2C.WriteRead(DEVICE_ADDR, Write_buffer, Read_buffer);

            return Read_buffer[0];
        }

        /// <summary>
        /// Gets the width of the display.
        /// </summary>
        public override uint Width { get { return m_currWidth; } }

        /// <summary>
        /// Gets the height of the display.
        /// </summary>
        public override uint Height { get { return m_currHeight; } }

        /// <summary>
        /// Renders display data on the display device. 
        /// </summary>
        /// <param name="bitmap">The <see cref="T:Microsoft.SPOT.Bitmap"/> object to render on the display.</param>
        protected override void Paint(Bitmap bitmap)
        {
            try
            {
                bitmap.Flush();
            }
            catch
            {
                ErrorPrint("Painting error");
            }
        }


    }
}
