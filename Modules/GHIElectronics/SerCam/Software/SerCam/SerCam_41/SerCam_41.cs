using Microsoft.SPOT;

using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;

using System.Threading;

namespace Gadgeteer.Modules.GHIElectronics
{
    /// <summary>
    /// A SerCam module for Microsoft .NET Gadgeteer
    /// </summary>
    public class SerCam : GTM.Module
    {
        private GTI.Serial serialPort;
        private const int DELAY_TIME = 200;
        //private static byte[] dataJPG;

        /// <summary>
        /// 
        /// </summary>
        public enum Camera_Resolution
        {
            /// <summary>
            /// 
            /// </summary>
            SIZE_VGA = 0x00,

            /// <summary>
            /// 
            /// </summary>
            SIZE_QVGA = 0x11,

            /// <summary>
            /// 
            /// </summary>
            SIZE_QQVGA = 0x22,
        };

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public SerCam(int socketNumber)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);

            socket.EnsureTypeIsSupported('U', this);

            serialPort = new GTI.Serial(socket, 115200, GTI.Serial.SerialParity.None, GTI.Serial.SerialStopBits.One, 8, GTI.Serial.HardwareFlowControl.NotRequired, this);
            serialPort.ReadTimeout = 5000;
            serialPort.WriteTimeout = 5000;

            serialPort.Open();

            ResetCamera();
        }

        //// Baudrate
        //private static ushort BAUDRATE_9600 = 0xAEC8;
        //private static ushort BAUDRATE_19200 = 0x56E4;
        //private static ushort BAUDRATE_38400 = 0x2AF2;
        //private static ushort BAUDRATE_57600 = 0x1CC4;
        //private static ushort BAUDRATE_115200 = 0x0DA6;

        private Thread thread;

        #region Picture Capture
        /// <summary>
        /// 
        /// </summary>
        public void TakePicture()
        {
            if (thread == null)
            {
                thread = new Thread(ts);
                thread.Start();
            }
            else
            {
                if (thread.ThreadState == ThreadState.Running)
                    Debug.Print("Cannot take picture at this time");
                else
                {
                    thread = new Thread(ts);
                    thread.Start();
                }
            }
        }

        private void ts()
        {
            ResetCamera();

            StopFrameBufferControl();

            int size = GetFrameBufferLength();

            byte[] data = ReadFrameBuffer(size);

            //GT.Picture pic = new Picture(data, Picture.PictureEncoding.JPEG);

            OnPictureCapturedEvent(this, new Bitmap(data, Bitmap.BitmapImageType.Jpeg));
        }

        private bool StopFrameBufferControl()
        {
            CleanSerialPort();

            byte[] send = new byte[] { 0x56, 0x00, 0x36, 0x01, 0x00 };
            serialPort.Write(send, 0, send.Length);

            Thread.Sleep(DELAY_TIME);

            byte[] receive = ReadBytes();

            if (receive != null && receive.Length >= 4)
            {
                if (receive[0] == 0x76 && receive[1] == 0 && receive[2] == 0x36 && receive[3] == 0 && receive[4] == 0)
                {
                    return true;
                }
            }

            return false;
        }

        private int GetFrameBufferLength()
        {
            CleanSerialPort();

            byte[] send = new byte[] { 0x56, 0x00, 0x34, 0x01, 0x00 };

            serialPort.Write(send, 0, send.Length);

            Thread.Sleep(DELAY_TIME);

            int size = 0;
            byte[] receive = ReadBytes();

            if (receive != null && receive.Length >= 9)
            {
                if (receive[0] == 0x76 && receive[1] == 0 && receive[2] == 0x34 && receive[3] == 0 && receive[4] == 0x4)
                {
                    size = receive[5] << 24 | receive[6] << 16 | receive[7] << 8 | receive[8];
                }
            }
            return size;
        }

        private byte[] ReadFrameBuffer(int size)
        {
            CleanSerialPort();

            byte[] size4byte = new byte[4];
            byte[] header = new byte[10];
            size4byte[0] = (byte)(size >> 24);
            size4byte[1] = (byte)(size >> 16);
            size4byte[2] = (byte)(size >> 8);
            size4byte[3] = (byte)(size);
            //dataJPG = new byte[size + 10];

            byte[] data = new byte[size];
            byte[] send = new byte[] { 0x56, 0x00, 0x32, 0x0C, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, size4byte[0], size4byte[1], size4byte[2], size4byte[3], 0x0B, 0xB8 };
            serialPort.Write(send, 0, send.Length);
            Thread.Sleep(3);

            // Read header
            ReadBytes(header, 0, 5);

            // Read data
            ReadBytes(data, 0, size);
           
            // read header
            ReadBytes(header, 5, 5);

            return data;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="resolution"></param>
        /// <returns></returns>
        public bool SetImageSize(Camera_Resolution resolution)
        {
            byte[] send = new byte[] { 0x56, 0x00, 0x31, 0x05, 0x04, 0x01, 0x00, 0x19, (byte)resolution };

            serialPort.Write(send, 0, send.Length);

            Thread.Sleep(DELAY_TIME);

            byte[] receive = ReadBytes();
            if (receive != null && receive[0] == 0x76 && receive[1] == 0x00 && receive[2] == 0x31 && receive[3] == 0x00 && receive[4] == 0x00)
            {
                return true;
            }

            return false;
        }
        #endregion

        #region Helper Functions
        private string ResetCamera()
        {
            byte[] send = new byte[] { 0x56, 0x00, 0x26, 0x00 };

            serialPort.Write(send, 0, send.Length);

            Thread.Sleep(DELAY_TIME);

            byte[] receive = ReadBytes();

            if (receive != null && receive.Length > 0)
            {
                Thread.Sleep(DELAY_TIME);
                return ConvertBytesToString(receive);
            }
            else
            {
                Thread.Sleep(DELAY_TIME);
                return "";
            }
        }

        private string ConvertBytesToString(byte[] data)
        {
            string str = "";

            for (int i = 0; i < data.Length; i++)
            {
                str += new string(new char[] { (char)(data[i]) });
            }

            return str;
        }

        private void CleanSerialPort()
        {
            serialPort.DiscardInBuffer();
            serialPort.DiscardOutBuffer();
        }

        private byte[] ReadBytes()
        {
            byte[] data = null;
            int byteread = serialPort.BytesToRead;
            if (byteread > 0)
            {
                data = new byte[byteread];
                ReadBytes(data, 0, data.Length);
            }
            return data;
        }
        //TQD
        int ReadBytes(byte[] data, int offset)
        {
            int byteread = serialPort.BytesToRead;
            if (byteread > 0)
            {
                serialPort.Read(data, offset, byteread);
            }
            return byteread;
        }
        private void ReadBytes(byte[] data, int offset, int count)
        {
            serialPort.Read(data, offset, count);
        }
        #endregion
        #region Events
        /// <summary>
        /// Represents the delegate that is used for the <see cref="PictureCaptured"/> event.
        /// </summary>
        /// <param name="sender">The <see cref="SerCam"/> object that raised the event.</param>
        /// <param name="picture">A <see cref="T:Gadgeteer.Picture"/> containing the captured image.</param>
        public delegate void PictureCapturedEventHandler(SerCam sender, Bitmap picture);

        /// <summary>
        /// Event raised when the <see cref="SerCam"/> has completed an image capture.
        /// </summary>
        /// <remarks>
        /// Handle the <see cref="PictureCaptured"/> event to process image data
        /// after you call the <see cref="TakePicture"/> method. These methods 
        /// process the image data from the camera asynchronously, 
        /// and raise this event when the processing is complete.
        /// </remarks>
        public event PictureCapturedEventHandler PictureCaptured;

        private PictureCapturedEventHandler OnPictureCaptured;

        /// <summary>
        /// Raises the <see cref="PictureCaptured"/> event.
        /// </summary>
        /// <param name="sender">The <see cref="SerCam"/> that raised the event.</param>
        /// <param name="picture">A <see cref="T:Gadgeteer.Picture"/> containing the captured image.</param>
        protected virtual void OnPictureCapturedEvent(SerCam sender, Bitmap picture)
        {
            if (OnPictureCaptured == null) OnPictureCaptured = new PictureCapturedEventHandler(OnPictureCapturedEvent);
            if (Program.CheckAndInvoke(PictureCaptured, OnPictureCaptured, sender, picture))
            {
                PictureCaptured(sender, picture);
            }
        }
        #endregion
    }
}
