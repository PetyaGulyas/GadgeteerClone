using System;

using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;

namespace Gadgeteer.Modules.GHIElectronics
{
    /// <summary>
    /// A MaxO module for Microsoft .NET Gadgeteer
    /// </summary>
    public class MaxO : GTM.Module
    {
        private static GTI.SPI spi;
        private static GTI.SPI.Configuration config;

        private static GTI.DigitalOutput Enable;
        private static GTI.DigitalOutput CLR;

        private static byte[] data;
        private static bool reSized = false;

        private static int numBoards;

        /// <summary>
        /// The number of this type of module attached together
        /// </summary>
        public int NumBoards
        {
            get
            {
                return MaxO.numBoards;
            }
            set
            {
                if (!reSized)
                {
                    MaxO.numBoards = value;
                    data = new byte[numBoards * 4];
                    reSized = true;
                }
                else
                {
                    throw new Exception("Number of boards attached my not be changed once it has been set!");
                }
            }
        }

        /// <summary>
        /// Returns the size of the array to be filled out.
        /// </summary>
        /// <returns></returns>
        public int GetArraySize()
        {
            return data.Length;
        }

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public MaxO(int socketNumber)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            Socket socket = Socket.GetSocket(socketNumber, true, this, null);
            socket.EnsureTypeIsSupported('S', this);

            config = new GTI.SPI.Configuration(false, 0, 0, false, true, 1000);
            spi = new GTI.SPI(socket, config, GTI.SPI.Sharing.Shared, socket, Socket.Pin.Five, this);

            Enable = new GTI.DigitalOutput(socket, Socket.Pin.Three, false, this);
            CLR = new GTI.DigitalOutput(socket, Socket.Pin.Four, true, this);

            numBoards = 0;
        }

        /// <summary>
        /// Clears all registers.
        /// </summary>
        public void Clear()
        {
            if (!reSized)
            {
                ErrorPrint("The array has not been sixed yet. Please indicate how many modules are chained before continuing");
            }

            Enable.Write(true);
            CLR.Write(false);

            System.Threading.Thread.Sleep(10);
            byte[] clear = new byte[1] { 0 };
            spi.Write(clear);

            CLR.Write(true);
            Enable.Write(false);
        }

        /// <summary>
        /// Writes the full array of data to the registers.
        /// </summary>
        /// <param name="arr"></param>
        public void WriteArray(byte[] arr)
        {
            if (!reSized)
            {
                throw new Exception("No boards have been initialized! Please indicate how many modules are chained before writing");
            }

            if (arr.Length != data.Length)
            {
                throw new Exception("Passed in array not the same size as the number of registers!");
            }

            Enable.Write(true);
            {
                byte[] reversedArr = new byte[arr.Length];
                Array.Copy(arr, reversedArr, arr.Length);

                for (int i = 0; i < reversedArr.Length; i++)
                {
                    reversedArr[i] = (byte)(~reversedArr[i]);
                }

                spi.Write(reversedArr);
                Array.Copy(arr, data, arr.Length);
            }
            Enable.Write(false);
        }

        /// <summary>
        /// Writes only to the specified pin or the specified board.
        /// </summary>
        /// <param name="_board">The number of the board to write to.</param>
        /// <param name="_pin">The number of the pin to write.</param>
        /// <param name="_value">The value to write to the pin.</param>
        public void WritePin(int _board, int _pin, bool _value)
        {
            if (!reSized)
            {
                throw new Exception("No boards have been initialized! Please indicate how many modules are chained before writing");
            }

            // check to see if the pin is inside our range
            int length = ((_board) * 4);// +_pin;
            int position = ((_board - 1) * 4) + _pin;

            if (length > data.Length)
                throw new Exception("Invalid pin position. Pin out of range");

            // make a "dummy" to turn our pin on or off
            byte[] dummy = new byte[data.Length];

            Array.Copy(data, dummy, data.Length);

            // find exact bit position
            int blockPos = dummy.Length - (((_board - 1) * 4) + (_pin / 8));
            blockPos--;
            if (_value)
            {
                dummy[blockPos] = (byte)(data[blockPos] & ~(1 << ((_pin % 8) - 1)));
                WriteArray(dummy);
            }
            else
            {
                dummy[blockPos] = (byte)(data[blockPos] | (1 << ((_pin % 8) - 1)));
                WriteArray(dummy);
            }
        }

        /// <summary>
        /// Returns the data that is currently in the registers.
        /// </summary>
        /// <returns></returns>
        public byte[] Read()
        {
            if (!reSized)
            {
                throw new Exception("No boards have been initialized! Please indicate how many modules are chained before writing");
            }

            return data;
        }

        /// <summary>
        /// Enables output to the pins.
        /// </summary>
        public void EnableOutputs()
        {
            if (!reSized)
            {
                throw new Exception("No boards have been initialized! Please indicate how many modules are chained before writing");
            }

            Enable.Write(false);
        }

        /// <summary>
        /// Disables the output to the pins.
        /// </summary>
        public void DisableOutputs()
        {
            if (!reSized)
            {
                throw new Exception("No boards have been initialized! Please indicate how many modules are chained before writing");
            }

            Enable.Write(true);
        }
    }
}